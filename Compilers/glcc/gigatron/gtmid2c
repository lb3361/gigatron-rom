#!/usr/bin/env python3

import sys, os, argparse, struct

progname = 'gtmid2c'

filedata = None
hasvolume = True
args = None
headersize = 41

# ----------------------------------------
# PARSE FILE

ops = []

def parsedata():
    global ops
    ops = []
    if hasvolume:
        vols = [-1,-1,-1,-1]
    i = headersize
    while i < len(filedata):
        cmd = filedata[i]; i+=1
        channel = cmd & 3
        if cmd < 128:
            ops.append(f"D({cmd})")
        elif cmd & 0xf0 == 128:
            ops.append(f"X({channel+1})")
        elif cmd & 0xf0 == 144:
            note = filedata[i]; i+=1
            if note < 12 or note > 106:
                warning(f"Note {note} out of range")
                note = 12 if note < 12 else 106 if note > 106 else note
            if hasvolume:
                vol = filedata[i]; i+=1
                if vol < 0 or vol > 255:
                    warning(f"Volume {vol} out of range")
                    vol = vol & 0xff
            if hasvolume and vol != vols[channel]:
                ops.append(f"M({channel+1},{note},{vol})")
                vols[channel] = vol
            else:
                ops.append(f"N({channel+1},{note})")
        else:
            error(f"Unexpected construct in file {infile}: (cmd={hex(cmd)})")

def opsize(op):
    if op[0]=='M':
        return 3
    if op[0]=='N':
        return 2
    return 1

def countsegments():
    n = s = ts = 0
    for op in ops:
        if s + 3 >= args.segsize:
            n += 1;
            ts += 1;
            s = 0;
        x = opsize(op)
        s += x
        ts += x
    return n + 1, ts + 1 + n + n + 2

def printheader(fd, ns, sz):
    print(f'''
/* extern const byte* {args.identifier}[];
 * -- generated by {progname} from file {args.infile}
 *    memsize {sz} in {ns} segments
 */''', file=fd)
    if not args.no_prologue:
        print(f'''
#define D(x) x                     /* wait x frames */
#define X(c) 127+(c)               /* channel c off */
#define N(c,n) 143+(c),(n)         /* channel c on, note=n */
#define M(c,n,v) 159+(c),(n),(v)   /* channel c on, note=n, wavA=v */
#define byte unsigned char
#define nohop __attribute__((nohop))\n''', file=fd)

def printdata(fd):
    ns, sz = countsegments()
    printheader(fd, ns, sz)
    n = s = z = 0
    c = ''
    for op in ops:
        if s + 3 >= args.segsize:
            s = z = 0
            n = n + 1
            print(f'{c}0\n}};', file=fd)
        if s == 0:
            print(f'nohop static const byte {args.identifier}{n:03d}[] = {{', file=fd, end='')
            c = ''
        if z > 72:
            z = 0
        if z == 0:
            print(f'{c}\n  ', file=fd, end='')
            c = ','
        else:
            print(c, file=fd, end='')
        print(op, file=fd, end='')
        z += 1+len(op)
        s += opsize(op)
        c = ','
    print(f'{c}0\n}};\n', file=fd)
    print(f'nohop const byte *{args.identifier}[] = {{', file=fd)
    for n in range(ns):
        print(f'  {args.identifier}{n:03d},', file=fd)
    print(f'  0\n}};', file=fd)




# ----------------------------------------
# MAIN

def warning(s):
    print(f'{progname}: warning: {s}', file=sys.stderr)

def error(s):
    print(f'{progname}: error: {s}', file=sys.stderr)
    sys.exit(1)

def main(argv):
    global filedata, hasvolume, args
    try:
        # parse arguments
        parser = argparse.ArgumentParser(
            usage = f'{progname} [options] infile.gtmid [outfile.c]',
            description = 'Convert a gtmidi file into a compilable c file',
            epilog = '''This programs reads a gtmidi file (as produced by at67 gtmidi program)
            and outputs a c file that defines a data structure that can be passed
            to function midi_play().''')
        parser.add_argument('-s', '--segment-size', action='store', type=int, default=96, dest='segsize',
                            help='maximum segnent size (default 96)')
        parser.add_argument('-i', '--identifier', action='store', type=str, default=None,
                            help='identifier for the c data (default as in the header)')
        parser.add_argument('-n', '--no-prologue', action='store_true',
                            help='do not output the file prologue')
        parser.add_argument('infile', action='store', type=str)
        parser.add_argument('outfile', action='store', nargs='?', type=str)
        args = parser.parse_args(argv)
        # process defaults
        if args.infile and not args.infile.endswith('.gtmid'):
            warning(f'input file {args.infile} does not have a .gtmid suffix')
        if args.outfile and not args.outfile.endswith('.c'):
            warning(f'output file {args.outfile} does not have a .c suffix')
        if args.segsize < 32 or args.segsize > 256:
            error('segment size must be in range 32 to 256')
        # read file
        with open(args.infile,'rb') as fd:
            filedata = fd.read()
        header = struct.unpack('>6s32sbh', filedata[0:headersize])
        if header[0] != b'gtMIDI':
            error(f'input file {args.infile} does look like a gtmid file')
        if not args.identifier:
            args.identifier = header[1].decode('latin=1').rstrip('\x00')
        hasvolume = header[2] != 0
        if len(filedata) != 41 + header[3]:
            warning(f'input file {args.infile} size does not match the header data ({header[2]})')
        # parse file
        parsedata()
        # output c
        if args.outfile:
            with open(args.outfile,'w') as fd:
                printdata(fd)
        else:
            printdata(sys.stdout)
        return 0
    except FileNotFoundError as err:
        error(str(err))
#    except Exception as err:
#        error(str(err))

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))

# Local Variables:
# mode: python
# indent-tabs-mode: ()
# End:
